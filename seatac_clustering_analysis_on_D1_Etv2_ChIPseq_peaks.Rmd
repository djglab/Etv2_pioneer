---
title: "Exploring the procedures to cluster V-plot by using SeATAC results"
author: "Wuming Gong"
date: "12/26/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message = FALSE}
library(Matrix)
library(dplyr)
library(irlba)
library(gplots)
```

# Read the SeATAC results (num_rads cutoff=10)
peak set: Etv2 ChIP-seq peaks at D1 post Etv2 induction
BAM: ATAC-seq of undifferentiated MEFs
num_reads cutoff: 10
```{r}
gr <- readRDS(gzcon(url('https://s3.msi.umn.edu/gongx030/projects/seatac/models/peak=MEF_Dox_d1_Etv2_bam=MEF_NoDox_latent_dim=10_window_size=640_bin_size=5_fragment_size_range=50+370_fragment_size_interval=5/predict.rds')))
```

# Cluster the V-plot only using fragment size profile
```{r, warning = FALSE}
fragment_size <- gr$fragment_size_profile
fragment_size <- Diagonal(x = 1 / rowSums(fragment_size)) %*% fragment_size %>% as.matrix() # scale to sum of one for each sample
wss <- (nrow(fragment_size)-1) * sum(apply(fragment_size,2,var))
for (i in 2:15) wss[i] <- sum(kmeans(fragment_size, centers=i)$withinss)
plot(1:15, wss, type="b", xlab="Number of Clusters", ylab="Within groups sum of squares")
```

```{r, warning = FALSE}
k <- 10
set.seed(1); cls <- kmeans(fragment_size, k)$cluster
```


```{r, fig.width = 12, fig.height = 15}
par(mfrow = c(k, 6), mar = c(2, 2, 2, 1))
bg <- colMeans(mcols(gr)$counts)
for (i in 1:k){
  x <- colMeans(mcols(gr)$counts[cls == i, ])
  x_norm <- matrix(x - bg, metadata(gr)$n_bins_per_window, metadata(gr)$n_intervals)
  image(x_norm, col = colorpanel(100, low = 'blue', mid = 'white', high = 'red'), main = sprintf('cluster %d(%d)', i, sum(cls == i)), axes = FALSE)
  
  x_non_norm <- matrix(x, metadata(gr)$n_bins_per_window, metadata(gr)$n_intervals)
  image(x_non_norm, col = colorpanel(100, low = 'blue', mid = 'white', high = 'red'), main = 'Raw signal', axes = FALSE)
  
  plot(colMeans(fragment_size[cls == i, ]), main = 'Fragment size')
  
  plot(colMeans(gr$nfr_reads[cls == i, ]), main = 'NFR reads')
  
  plot(colMeans(gr$mono_nucleosome_reads[cls == i, ]), main = 'Mono nucleosome reads')
  
  plot(colMeans(gr$MEF_MNase[cls == i, ]), main = 'MEF MNase')
}
```

# Use two features for v-plot clustering
1. ratio between total NFR reads and mono nucleosome reads
2. ratio between NFR reads and mono nucleosome reads at the center
```{r, fig.width = 8}
h <- log(rowSums(gr$nfr_reads[, (64 - 3):(64 + 3)]) + 1) - log(rowSums(gr$mono_nucleosome_reads[, (64 - 3):(64 + 3)]) + 1)
v <- log(rowSums(gr$nfr_reads) + 1) - log(rowSums(gr$mono_nucleosome_reads) + 1)
par(mfrow = c(1, 2))
k <- 4
set.seed(1); cls <- kmeans(cbind(h, v), k)$cluster
boxplot(split(gr$num_reads, list(cls)), col = 1:k, log = 'y', main = 'number of reads', ylab = 'Number of reads')
plot(h, v, pch = 21, bg = cls, xlab = 'ratio between center NFR and mono reads', ylab = 'ratio between total NFR and mono reads')
abline(h = 0, v = 0, lty = 2)
```
Overall, this gave the better performance. Cluster 2 and 3 were recoevered successfully. 
However, cluster 1 and 4 were poorly recovered, probably just due to the low number of reads. 
It looks like the num_reads cutoff of 10 is not stringent enough and will generate many ambiguious predictions.  
```{r, fig.width = 12, fig.height = 8}
par(mfrow = c(k, 6), mar = c(2, 2, 2, 1))
bg <- colMeans(mcols(gr)$counts)
for (i in 1:k){
  x <- colMeans(mcols(gr)$counts[cls == i, ])
  x_norm <- matrix(x - bg, metadata(gr)$n_bins_per_window, metadata(gr)$n_intervals)
  image(x_norm, col = colorpanel(100, low = 'blue', mid = 'white', high = 'red'), main = sprintf('cluster %d(%d)', i, sum(cls == i)), axes = FALSE)
  
  x_non_norm <- matrix(x, metadata(gr)$n_bins_per_window, metadata(gr)$n_intervals)
  image(x_non_norm, col = colorpanel(100, low = 'blue', mid = 'white', high = 'red'), main = 'Raw signal', axes = FALSE)
  
  plot(colMeans(gr$fragment_size_profile[cls == i, ]), main = 'Fragment size')
  
  plot(colMeans(gr$nfr_reads[cls == i, ]), main = 'NFR reads')
  
  plot(colMeans(gr$mono_nucleosome_reads[cls == i, ]), main = 'Mono nucleosome reads')
  
  plot(colMeans(gr$MEF_MNase[cls == i, ]), main = 'MEF MNase')
}
```


# Read the SeATAC results (num_rads cutoff=20)
peak set: Etv2 ChIP-seq peaks at D1 post Etv2 induction
BAM: ATAC-seq of undifferentiated MEFs
num_reads cutoff: **20**
```{r}
gr <- readRDS(gzcon(url('https://s3.msi.umn.edu/gongx030/projects/seatac/models/peak=MEF_Dox_d1_Etv2_bam=MEF_NoDox_latent_dim=10_window_size=640_bin_size=5_fragment_size_range=50+370_fragment_size_interval=5_min_num_reads=20_max_num_reads=500/predict.rds')))
```

# Use two features for v-plot clustering
1. ratio between total NFR reads and mono nucleosome reads
2. ratio between NFR reads and mono nucleosome reads at the center
```{r, fig.width = 8}
h <- log(rowSums(gr$nfr_reads[, (64 - 3):(64 + 3)]) + 1) - log(rowSums(gr$mono_nucleosome_reads[, (64 - 3):(64 + 3)]) + 1)
v <- log(rowSums(gr$nfr_reads) + 1) - log(rowSums(gr$mono_nucleosome_reads) + 1)
par(mfrow = c(1, 2))
k <- 2
```

```{r, fig.width = 8}
set.seed(1); cls <- kmeans(cbind(h, v), k)$cluster
par(mfrow = c(1, 2))
boxplot(split(gr$num_reads, list(cls)), col = 1:k, log = 'y', main = 'number of reads', ylab = 'Number of reads')
plot(h, v, pch = 21, bg = cls, xlab = 'ratio between center NFR and mono reads', ylab = 'ratio between total NFR and mono reads')
abline(h = 0, v = 0, lty = 2)
```

```{r, fig.width = 12, fig.height = 4}
par(mfrow = c(k, 6), mar = c(2, 2, 2, 1))
bg <- colMeans(mcols(gr)$counts)
breaks_non_norm <- c(seq(0, max(bg) * 0.9, length.out = 100), 1)
breaks_norm <- c(-1, seq(-0.01, 0.01, length.out = 99), 1)
for (i in 1:k){
  x <- colMeans(mcols(gr)$counts[cls == i, ])
  x_norm <- matrix(x - bg, metadata(gr)$n_bins_per_window, metadata(gr)$n_intervals)
  image(x_norm, col = colorpanel(100, low = 'blue', mid = 'white', high = 'red'), breaks = breaks_norm, main = sprintf('cluster %d(%d)', i, sum(cls == i)), axes = FALSE)
  
  x_non_norm <- matrix(x, metadata(gr)$n_bins_per_window, metadata(gr)$n_intervals)
  image(x_non_norm, col = colorpanel(100, low = 'blue', mid = 'white', high = 'red'), breaks = breaks_non_norm, main = 'Raw signal', axes = FALSE)
  
  plot(colMeans(gr$fragment_size_profile[cls == i, ]), main = 'Fragment size')
  
  plot(colMeans(gr$nfr_reads[cls == i, ]), main = 'NFR reads')
  
  plot(colMeans(gr$mono_nucleosome_reads[cls == i, ]), main = 'Mono nucleosome reads')
  
  plot(colMeans(gr$MEF_MNase[cls == i, ]), main = 'MEF MNase')
}
```

```{r}
sessionInfo()
```